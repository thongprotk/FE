import { useState, useRef, useEffect } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import {
  Loader2,
  Sparkles,
  BookOpenText,
  Bot,
  User as UserIcon,
  CheckCircle2,
  AlertCircle,
} from "lucide-react";
import { ToastContainer } from "@/components/toast-container";
import { useToast } from "@/hooks/useToast";
import { resourceService } from "@/services/resource.service";
import { deckService } from "@/services/deck.service";
import { cardService } from "@/services/card.service";
import { promptTemplateService } from "@/services/prompt-template.service";
import { PromptPreview } from "@/components/PromptPreview";
import useResourceSocket from "@/hooks/useResourceSocket";
import type { PromptTemplate } from "@/services/prompt-template.service";

type ChatMessage = {
  role: "user" | "assistant";
  content: string;
  timestamp?: number;
};

export default function LessonBuilderPage() {
  const [content, setContent] = useState("");
  const [url, setUrl] = useState("");
  const [title, setTitle] = useState("");
  const [promptTemplate, setPromptTemplate] = useState<PromptTemplate | null>(
    null
  );
  const [templates, setTemplates] = useState<PromptTemplate[]>([]);
  const [messages, setMessages] = useState<ChatMessage[]>([
    {
      role: "assistant",
      content:
        "Ch√†o b·∫°n! D√°n b√†i vi·∫øt ho·∫∑c nh·∫≠p n·ªôi dung t·∫°i ƒë√¢y. M√¨nh s·∫Ω d√πng AI ƒë·ªÉ sinh flashcards v√† t·∫°o b√†i h·ªçc t·ª± ƒë·ªông cho b·∫°n.",
      timestamp: Date.now(),
    },
  ]);
  const [statusMessage, setStatusMessage] = useState("");
  const [error, setError] = useState("");
  const [isSaving, setIsSaving] = useState(false);
  const [lastResourceId, setLastResourceId] = useState<string | null>(null);
  const [isGeneratingCards, setIsGeneratingCards] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const { success: showSuccess, error: showError, info: showInfo } = useToast();

  // Load prompt templates on mount
  useEffect(() => {
    const loadTemplates = async () => {
      try {
        const flashcardTemplates = await promptTemplateService.getByCategory(
          "FLASHCARD"
        );
        setTemplates(flashcardTemplates);
        if (flashcardTemplates.length > 0) {
          setPromptTemplate(flashcardTemplates[0]);
        }
      } catch (err) {
        console.error("Failed to load prompt templates:", err);
      }
    };
    loadTemplates();
  }, []);

  // Auto-scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  /**
   * Auto-generate Deck from resource and AI summary
   */
  const autoGenerateDeck = async (
    resourceId: string,
    aiSummary: string
  ): Promise<string | null> => {
    try {
      // Generate deck name from first 50 chars of summary
      const deckTitle =
        aiSummary.substring(0, 50).split("\n")[0] || "AI Generated Deck";

      const deck = await deckService.create({
        title: deckTitle,
        description: `Generated from AI summary: ${aiSummary.substring(
          0,
          100
        )}...`,
      });

      showSuccess("T·∫°o b·ªô h·ªçc th√†nh c√¥ng", `B·ªô h·ªçc "${deckTitle}" ƒë√£ ƒë∆∞·ª£c t·∫°o`);
      return deck.id;
    } catch (err: any) {
      const message = err?.message || "Kh√¥ng th·ªÉ t·∫°o b·ªô h·ªçc. Vui l√≤ng th·ª≠ l·∫°i.";
      showError("L·ªói t·∫°o b·ªô h·ªçc", message);
      return null;
    }
  };

  /**
   * Auto-create flashcards from resource after AI completes
   */
  const autoGenerateFlashcards = async (resourceId: string, deckId: string) => {
    try {
      setIsGeneratingCards(true);
      const result = await resourceService.generateFlashcards(
        resourceId,
        deckId
      );
      showSuccess(
        "T·∫°o flashcards th√†nh c√¥ng",
        `${result.count} flashcards ƒë√£ ƒë∆∞·ª£c t·∫°o!`
      );

      setMessages((prev) => [
        ...prev,
        {
          role: "assistant",
          content: `‚úÖ T·∫°o th√†nh c√¥ng ${result.count} flashcards! B·∫°n c√≥ th·ªÉ xem chi ti·∫øt trong Decks.`,
          timestamp: Date.now(),
        },
      ]);
    } catch (err: any) {
      const message =
        err?.message || "Kh√¥ng th·ªÉ sinh flashcards. Vui l√≤ng th·ª≠ l·∫°i.";
      showError("L·ªói sinh flashcards", message);
    } finally {
      setIsGeneratingCards(false);
    }
  };

  const saveResource = async () => {
    setError("");
    setStatusMessage("");

    const trimmedContent = content.trim();
    if (!trimmedContent || trimmedContent.length < 10) {
      setError("Nh·∫≠p √≠t nh·∫•t 10 k√Ω t·ª± n·ªôi dung tr∆∞·ªõc khi g·ª≠i.");
      return;
    }

    const resourceTitle =
      title.trim() || "AI Resource - " + new Date().toLocaleString("vi-VN");
    const userMessage = `üìù N·ªôi dung:\n${trimmedContent}${
      url ? `\n\nüîó Ngu·ªìn: ${url}` : ""
    }`;
    setMessages((prev) => [
      ...prev,
      { role: "user", content: userMessage, timestamp: Date.now() },
    ]);

    setIsSaving(true);
    try {
      const payload = {
        title: resourceTitle,
        url: url.trim() || undefined,
        content: trimmedContent,
        aiRequested: true, // ‚úÖ Request AI processing
        promptTemplateKey: promptTemplate?.templateKey,
      };

      const saved = await resourceService.create(payload);
      setLastResourceId(saved.id);

      const aiResponse =
        "‚è≥ ƒê√£ nh·∫≠n n·ªôi dung. AI ƒëang ph√¢n t√≠ch ƒë·ªÉ sinh flashcards...";
      setMessages((prev) => [
        ...prev,
        { role: "assistant", content: aiResponse, timestamp: Date.now() },
      ]);
      setStatusMessage("");
      setError("");
      showInfo("ƒêang x·ª≠ l√Ω", "AI ƒëang ph√¢n t√≠ch n·ªôi dung c·ªßa b·∫°n...");
      setContent("");
      setUrl("");
      setTitle("");
    } catch (err: any) {
      const message =
        err?.message || "Kh√¥ng th·ªÉ l∆∞u n·ªôi dung. Ki·ªÉm tra ƒëƒÉng nh·∫≠p ho·∫∑c m·∫°ng.";
      setError(message);
      showError("L·ªói", message);
    } finally {
      setIsSaving(false);
    }
  };

  useResourceSocket((payload) => {
    console.log("[LessonBuilder] Received socket payload:", payload);
    // Only show updates relevant to the last created resource
    if (lastResourceId && payload.resourceId !== lastResourceId) {
      console.log(
        `[LessonBuilder] Ignoring update for ${payload.resourceId}, waiting for ${lastResourceId}`
      );
      return;
    }

    const status = payload.aiStatus || (payload as any).status; // Support both field names
    let messageText = "";

    if (status === "COMPLETED" && payload.aiSummary) {
      messageText = `‚úÖ AI ƒë√£ ho√†n t·∫•t!\n\nüìö T√≥m t·∫Øt:\n${payload.aiSummary}`;
      setStatusMessage("‚úì AI ƒë√£ ho√†n t·∫•t. ƒêang t·∫°o b·ªô h·ªçc v√† flashcards...");
      setError("");
      showSuccess(
        "X·ª≠ l√Ω th√†nh c√¥ng",
        "AI ƒë√£ ho√†n t·∫•t ph√¢n t√≠ch. ƒêang t·∫°o b·ªô h·ªçc..."
      );

      // üî• AUTO-GENERATE DECK AND FLASHCARDS
      (async () => {
        const deckId = await autoGenerateDeck(
          payload.resourceId,
          payload.aiSummary
        );
        if (deckId) {
          await autoGenerateFlashcards(payload.resourceId, deckId);
        }
      })();
    } else if (status === "FAILED") {
      messageText = `‚ùå AI x·ª≠ l√Ω th·∫•t b·∫°i.\n\nL·ªói: ${
        payload.error || "Kh√¥ng r√µ l√Ω do"
      }\n\nVui l√≤ng th·ª≠ l·∫°i.`;
      setError(
        "‚ùå AI x·ª≠ l√Ω th·∫•t b·∫°i. " + (payload.error || "Vui l√≤ng th·ª≠ l·∫°i sau.")
      );
      setStatusMessage("");
      showError("X·ª≠ l√Ω th·∫•t b·∫°i", payload.error || "Kh√¥ng r√µ l√Ω do");
    } else if (status === "PROCESSING") {
      messageText = "‚è≥ AI ƒëang x·ª≠ l√Ω... Vui l√≤ng ch·ªù.";
      setStatusMessage("‚è≥ AI ƒëang x·ª≠ l√Ω n·ªôi dung...");
      setError("");
    }

    if (messageText) {
      setMessages((prev) => [
        ...prev,
        { role: "assistant", content: messageText, timestamp: Date.now() },
      ]);
    }
  });

  return (
    <div className="min-h-screen bg-background flex flex-col">
      <ToastContainer />
      <header className="border-b bg-primary/5">
        <div className="max-w-5xl mx-auto px-4 py-4 flex items-center justify-between gap-3">
          <div className="flex items-center gap-2">
            <div className="h-9 w-9 bg-primary rounded-lg flex items-center justify-center">
              <Sparkles className="h-4 w-4 text-primary-foreground" />
            </div>
            <div>
              <h1 className="font-bold text-base">Flashcard Builder</h1>
              <p className="text-xs text-muted-foreground">
                Nh·∫≠p n·ªôi dung ‚Üí AI ph√¢n t√≠ch ‚Üí T·∫°o flashcards t·ª± ƒë·ªông
              </p>
            </div>
          </div>
          <Badge variant="secondary">AI Powered</Badge>
        </div>
      </header>

      <main className="flex-1 max-w-4xl mx-auto w-full px-4 py-6 flex flex-col gap-4 h-full">
        <Card className="flex-1 flex flex-col overflow-hidden">
          <CardContent className="flex-1 overflow-y-auto p-4 space-y-4">
            {messages.map((msg, idx) => (
              <div
                key={idx}
                className={`flex gap-3 ${
                  msg.role === "user" ? "justify-end" : "justify-start"
                }`}
              >
                <div
                  className={`flex items-start gap-2 max-w-[80%] ${
                    msg.role === "user" ? "flex-row-reverse" : ""
                  }`}
                >
                  <div
                    className={`h-8 w-8 rounded-full flex items-center justify-center shrink-0 ${
                      msg.role === "user"
                        ? "bg-blue-500 text-white"
                        : "bg-amber-500 text-white"
                    }`}
                  >
                    {msg.role === "user" ? (
                      <UserIcon className="h-4 w-4" />
                    ) : (
                      <Bot className="h-4 w-4" />
                    )}
                  </div>
                  <div
                    className={`rounded-lg p-3 ${
                      msg.role === "user"
                        ? "bg-blue-100 dark:bg-blue-900 text-foreground"
                        : "bg-muted text-foreground"
                    }`}
                  >
                    <p className="text-sm whitespace-pre-wrap wrap-break-word">
                      {msg.content}
                    </p>
                  </div>
                </div>
              </div>
            ))}
            {isGeneratingCards && (
              <div className="flex gap-3 justify-start">
                <div className="h-8 w-8 rounded-full flex items-center justify-center shrink-0 bg-amber-500 text-white">
                  <Loader2 className="h-4 w-4 animate-spin" />
                </div>
                <div className="rounded-lg p-3 bg-muted">
                  <p className="text-sm">ƒêang t·∫°o flashcards...</p>
                </div>
              </div>
            )}
            <div ref={messagesEndRef} />
          </CardContent>
        </Card>

        {/* Status/Error Messages */}
        {statusMessage && (
          <Alert className="bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800">
            <AlertDescription className="text-sm text-blue-900 dark:text-blue-100 flex items-center gap-2">
              <CheckCircle2 className="h-4 w-4" />
              {statusMessage}
            </AlertDescription>
          </Alert>
        )}
        {error && (
          <Alert variant="destructive">
            <AlertDescription className="text-sm flex items-center gap-2">
              <AlertCircle className="h-4 w-4" />
              {error}
            </AlertDescription>
          </Alert>
        )}

        {/* Chat Input Form - With URL & Prompt Preview */}
        <Card>
          <CardContent className="p-4">
            <div className="space-y-3">
              {/* Title Input */}
              <div>
                <label className="text-sm font-medium mb-1 block">
                  Ti√™u ƒë·ªÅ (t√πy ch·ªçn)
                </label>
                <Input
                  placeholder="Nh·∫≠p ti√™u ƒë·ªÅ b√†i h·ªçc ho·∫∑c ƒë·ªÉ tr·ªëng"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  disabled={isSaving || isGeneratingCards}
                  className="text-sm"
                />
              </div>

              {/* URL Input */}
              <div>
                <label className="text-sm font-medium mb-1 block">
                  URL Ngu·ªìn (t√πy ch·ªçn)
                </label>
                <Input
                  placeholder="https://example.com/article"
                  value={url}
                  onChange={(e) => setUrl(e.target.value)}
                  disabled={isSaving || isGeneratingCards}
                  type="url"
                  className="text-sm"
                />
                <p className="text-xs text-muted-foreground mt-1">
                  Cung c·∫•p URL ƒë·ªÉ AI c√≥ b·ªëi c·∫£nh t·ªët h∆°n
                </p>
              </div>

              {/* Prompt Template Selection */}
              {templates.length > 0 && (
                <div>
                  <label className="text-sm font-medium mb-1 block">
                    Ph∆∞∆°ng ph√°p AI
                  </label>
                  <div className="flex flex-wrap gap-2 mb-2">
                    {templates.map((template) => (
                      <Badge
                        key={template.id}
                        variant={
                          promptTemplate?.id === template.id
                            ? "default"
                            : "outline"
                        }
                        className="cursor-pointer"
                        onClick={() => setPromptTemplate(template)}
                      >
                        {template.name}
                      </Badge>
                    ))}
                  </div>
                  {promptTemplate && content.length >= 10 && (
                    <PromptPreview
                      template={promptTemplate}
                      url={url}
                      title={title}
                      content={content}
                      count={8}
                    />
                  )}
                </div>
              )}

              {/* Content Textarea */}
              <div>
                <label className="text-sm font-medium mb-1 block">
                  N·ªôi dung *
                </label>
                <Textarea
                  placeholder="Nh·∫≠p n·ªôi dung b√†i vi·∫øt ho·∫∑c b√†i h·ªçc. C√≥ th·ªÉ d√°n to√†n b·ªô n·ªôi dung ƒë√¢y..."
                  value={content}
                  onChange={(e) => setContent(e.target.value)}
                  className="min-h-32 text-sm resize-none"
                  disabled={isSaving || isGeneratingCards}
                />
              </div>

              <Button
                onClick={saveResource}
                className="w-full"
                disabled={
                  isSaving ||
                  isGeneratingCards ||
                  !content.trim() ||
                  content.trim().length < 10
                }
              >
                {isSaving ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    ƒêang g·ª≠i...
                  </>
                ) : isGeneratingCards ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    ƒêang t·∫°o flashcards...
                  </>
                ) : (
                  <>
                    <Sparkles className="h-4 w-4 mr-2" />
                    G·ª≠i cho AI
                  </>
                )}
              </Button>
            </div>
          </CardContent>
        </Card>
      </main>
    </div>
  );
}
